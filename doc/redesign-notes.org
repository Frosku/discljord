#+TITLE:Redesign Notes for Discljord
* Bot Application
  A bot application will be made up of several processes.
  These processes will communicate with each other, and that will
  provide the actual functionality of a Discord bot.

  The three required processes will be a Connection which will handle
  the actual connection with Discord's servers and event collection,
  a Bot which will take input events and ouput messages, and a Messaging
  process which will take input messages and send them to Discord's
  servers.

  Additional Connection and Bot processes may be created, but only
  one Messaging will be necessary for any given application. However,
  that may change later once implementation gets underway.
** Connection
   The connection will be a process which takes data from Discord, and puts
   it onto a pipeline for events. It will also handle sharding, and reconnections.
*** Discord Connection
    Handles recieving data from Discord and converting it to Clojure data
*** Event Creation
    Handles converting Clojure data representation of Discord messages,
    and converting that data into Discljord events

    Maybe implement this as a multimethod? That way it's extensible if Discord
    adds new events.

    These methods can also decide if it's an actual event that a bot should have
    access to as well, like perhaps it will ensure the bot only gets a disconnect
    message once it's failed to reconnect?
    #+BEGIN_SRC clojure
      (defmethod create-event 7 [proc-chan discord-event]
        (go (>! proc-chan {:type :message-create
                           :channel (:channel discord-event)
                           :data {:author (:author discord-event)
                                  :content (:message discord-event)}})))
    #+END_SRC
** Bot
   Bots will be a process which takes events off of a pipeline, and puts messages
   onto a pipeline. That means that a bot should also be able to have a "main"
   type function which is called when the bot is initially created.
   The Connection process will be the main source of events, but other things
   can create events as well, and those will be handled as well.

   As a note, the runtime for the bot should probably be defined as a macro
   instead of as a function, so that you can redefine a bot at the repl and
   have it affect the running process.
*** Event Dispatch
    Takes Discljord events and determines which event handlers to call
    with that event
    #+BEGIN_SRC clojure
      (defhandlers bot
        :connect load-state
        :message-create bot-respond
        :disconnect [cleanup-resources save-state])
    #+END_SRC
*** Event Handling
    Event handlers take a discord event and perform any operations needed,
    as well as sending messages to the relevant messaging process
    #+BEGIN_SRC clojure
      (defhandler bot-respond [event]
        (send-message (:channel event) "Hello! You sent a message!"))
    #+END_SRC
*** State Handling
    State is something that's difficult to maintain or prescribe about in bots.
    One thing that I do know is that if possible I want to maintain state about the
    bot in general, but I also want to maintain state specific to the guild that the
    event came from, if one exists.

    When dealing with the state and how handlers affect it, do I want handlers
    to interact with some kind of global state, like an atom? Or do I want them
    to thread that state from one operation to the next?

    One nice aspect of having event handling be an open system and process, is that
    users can create new process handlers and methods such that you can define your own
    new state type to use. As such I may support both atomic and threaded state.
**** Atomic State
     When you're dealing with atomic state for a bot, it means that you do IO all over
     the place in the bot. Pretty much every event handler has to do IO. However, this
     method also prescribes nothing about how you store your state. Only that you do it
     externally to the bot process itself.
**** Threaded State
     When you use threaded state, each event handler is done such that it takes
     the current state of the bot, and returns a new state for that bot based on the event,
     as well as sending messages to the messaging process. Could also make it so that instead
     of manually sending messages, instead create the message data you want to send, and then
     return that as a part of what you're returning, which is appended to a list of messages
     that an event causes, which is handled by the runtime of the bot. This prescribes a bit
     about state, and a bit about messaging, but not too much. One other downside is that it
     reduces how much can be parallel about it, but at the same time maybe not too badly since
     each handler should be functionally pure.
** Messaging
   Messaging will be a process which takes messages off of a pipeline and then
   sends them to Discord's server, or other servers. They should have a basic
   required structure, but have their data be extensible.
*** Message Handling
    Message handling should be implemented as a multimethod on messages,
    where the type of message determines how it's handled. That means that
    messaging is an extensible system, and can even be used to communicate with
    non-discord servers and applications.
* Old Redesign Notes
** Bot Creation
*** Components
**** Event Handlers
Discord bots are compositions of event handlers.
Event handlers are passed what occurred with the relevant
bot, and create a response.
*** Operators
**** Define Bot
You compose together event handlers into bots. The bots
become an aggregate of all the event handlers.
*** Run
**** Connect Bot
Bots are "run" by being connected to discord's servers,
which will then respond to events sent by discord using
the event handlers.
*** Hides
**** Connection
Connecting a bot to discord servers requires lots of net
code, ensuring the connection is stable, sending keep
alive messages, and the ack packets.
**** Disconnection
Disconnecting a bot requires ensuring that all shards
are properly disconnected and the bot no longer appears
online.
**** Reconnection
Reconnecting a bot requires net code and ensuring that
each shard is not reconnected multiple times on different
threads, as well as handling ack etc.
**** Shards
Sharding of bots allows multiple different sockets to
send events to the bot, and those events need to be serialized
and ensured that they are handled properly.
**** Multithreading
The bot in larger servers will likely have a lot of stuff
to handle at once, so it needs to be multithreaded to ensure
proper operation when in large numbers of servers.
** Event Handlers
*** Components
**** State Changes
**** Bot IO
*** Operators
**** Define Handler, Sequencing
**** Define Command
**** commands, first match command
*** Run
**** Bot connection
Handlers are run inside a bot that is connected
*** Hides
**** State Handling
**** Discord's Event Data
**** Matching Commands
** Bot State
